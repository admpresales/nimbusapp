#!/bin/bash

function usage()
{
    output "Usage: nimbusapp <IMAGE>:<VERSION> [OPTIONS] COMMAND"
    output -e ""
    output -e "Options:"
    output -e "  IMAGE       The Docker App file you wish to run. If no repository is provided, admpresales is assumed."
    output -e "              dockerapp is added if not explicitly stated."
    output -e "  VERSION     The version of the Docker App file you wish to run."
    output -e "  -s, --set   Enables you to set(override) default arguments"
    output -e "  -v          Mounts volume for IdeaProject in IntelliJ container into user's home directory - EXPERIMENTAL: ONLY USE IF YOU UNDERSTAND VOLUME MOUNTS"
    output -e "  -m          Mounts volume for .m2 in IntelliJ container into user's home directory - EXPERIMENTAL: ONLY USE IF YOU UNDERSTAND VOLUME MOUNTS"
    output -e "  -p          Docker-compose project name to use - EXPERIMENTAL NOT RECOMMENDED FOR CASUAL USERS"
    output -e "  -d, --debug Enable debugging output (use twice for verbose bash commands)"
    output -e "  -f, --force Skip all prompts - Use with caution, this option will happily delete your data without warning"
    output -e "  --version   Print the version of nimbusapp and exit"
    output -e ""
    output -e "Commands:"
    output -e "  down     Stop and remove containers"
    output -e "  inspect  Shows metadata and settings for a given application"
    output -e "  logs     Shows logs for containers"
    output -e "  ps       Lists containers"
    output -e "  pull     Pull service images"
    output -e "  render   Render the Compose file for the application"
    output -e "  rm       Remove stopped containers"
    output -e "  restart  Restart containers"
    output -e "  start    Start existing containers"
    output -e "  stop     Stop existing containers"
    output -e "  up       Creates and start containers"
    output -e "  version  Prints version information"
    output -e "  help     Prints this help message"
}

function version_info() {
    output "nimbusapp version $NIMBUS_RELEASE_VERSION"
    output "Released on $NIMBUS_RELEASE_DATE"
}

# Ensure the apps.config file is initialized
#
# Also upgrades from v1 to v2 file format.
# v2 includes project name, tries to eliminate extra .dockerapps, and is a bit easier to parse
function apps_init() {
    # If v2 file exists, nothing to do
    if grep '^\s*#\s*v2\s*$' "$file" >/dev/null 2>&1; then
        return
    fi

    local template="# v2"
    local file="${1-$ENV_FILE}"
    local tmp="${file}.tmp$$"
    local backup="${file}.v1-backup"

    local proj img repo tag

    # Easy path, no file! Create it and return
    if [[ ! -f "$file" ]]; then
        echo $template > "$file"
        return
    fi

    mv "$file" "$tmp"
    echo $template > "$file"

    while read proj img; do
        proj="${proj%.dockerapp}"
        IFS=/: read repo img tag <<< $img

        echo $proj $repo $img $tag
    done < "$tmp" > "$file"

    mv "$tmp" "$backup"
}

function apps_load() {
    apps_init

    local search="${1-$PROJECt}"
    local file="${2-$ENV_FILE}"
    local entry proj repo img ver

    debug "Searching apps for: ${search}"

    entry="$(grep "^${search}\s" "${file}")"

    debug "Apps found: ${entry}"

    if [[ -n $entry ]]; then
        read proj repo img ver <<< $entry

        REPOSITORY="${REPOSITORY-$repo}"
        VERSION="${VERSION-$ver}"
        IMAGE="${IMAGE-$img}"
    fi
}

function apps_save() {
    apps_init

    local file="${1-$ENV_FILE}"

    debug "Saving: $PROJECT $REPOSITORY $IMAGE $VERSION"

    # Remove previous entry for this project
    sed -i "/$PROJECT\b/d" "$file"

    # Write new entry
    echo $PROJECT $REPOSITORY $IMAGE $VERSION >> "$file"
}

# create folders to use for mount points
# currently not leverated by Intellij
function create_intellij_mount_points (){
    # if the folder doesn't exist, create it so it is owned by the user
    if [[ ! -d "${HOME}/${IDEA}" ]]
    then
        mkdir ${BASH_VERBOSE} ${HOME}/${IDEA}
    fi

    if [[ ! -d "${HOME}/.m2" ]]
    then
        mkdir ${BASH_VERBOSE} ${HOME}/.m2
    fi
}

function prompt_yn() {
    local PROMPT_TEXT=$"${1-Continue?} [y/n]"
    local USER_ANSWER

    echo -ne "${PROMPT_TEXT} "

    while read USER_ANSWER; do
        case "${USER_ANSWER}" in
        [yY]*)
            return 0
            ;;
        [nN]*)
            return 1
            ;;
        esac

        echo -ne "${PROMPT_TEXT} "
    done
}

# Colour codes
readonly C_REG="\e[39m"     # Regular colour
readonly C_BOLD="\e[1m"     # Bold font
readonly C_RED="\e[91m"     # Red colour
readonly C_RESET="\e[0m"    # Reset font and colour

prompt_delete() {
    echo
    echo -e "${C_BOLD}This action will ${C_BOLD}${C_RED}DELETE${C_REG} your containers and is ${C_BOLD}${C_RED}IRREVERSIBLE${C_RESET}!"
    echo
    echo -e "${C_BOLD}You may wish to use ${C_RESET}\`nimbusapp ... stop'${C_BOLD} to shut down your containers without deleting them${C_RESET}"
    echo
    echo -e "${C_BOLD}The following containers will be deleted:${C_RESET}"

    docker-compose -p "${PROJECT}" -f "$COMPOSE_FILE" ps -q | while read id; do
        docker inspect --format "- {{.Name}}" "$id"
    done
    echo

    prompt_yn "${C_BOLD}${C_RED}Do you wish to DELETE these containers?${C_RESET}"
    return $?
}

prompt_recreate() {
    echo
    echo -e "${C_BOLD}This action will cause one or more of your containers to be ${C_RED}DELETED${C_REG} and ${C_RED}RECREATED${C_REG}.${C_RESET}"
    echo
    echo -e "${C_BOLD}Recreating containers is normal when changing their configuration, such as image, tag and ports.${C_RESET}"
    echo
    echo -e "${C_BOLD}You may wish to use ${C_RESET}\`nimbusapp ... start'${C_BOLD} to start your existing containers.${C_RESET}"
    echo
    echo -e "${C_BOLD}The following containers will be recreated:${C_RESET}"

    for c in "$@"; do
        echo "- $c"
    done
    
    echo
    prompt_yn "${C_BOLD}${C_RED}Recreate the listed containers?${C_RESET}"
    return $?
}

check_recreate() {
    local composeFile="$1"

    local containers=($(docker-compose -p "$PROJECT" -f "$COMPOSE_FILE" ps -q))
    local recreate=()

    local service hash composeHash name

    for id in "${containers[@]}"; do
        service="$(docker inspect "$id" --format '{{index .Config.Labels "com.docker.compose.service"}}')"
        hash="$(docker inspect "$id" --format '{{index .Config.Labels "com.docker.compose.config-hash"}}')"
        
        composeHash="$(docker-compose -p "$PROJECT" -f "$COMPOSE_FILE" config --hash="$service")"

        if [[ "$service $hash" != "$composeHash" ]]; then
            name="$(docker inspect "$id" --format {{.Name}})"
            recreate+=("$name")
        fi
    done

    if [[ ${#recreate[@]} -gt 0 ]]; then
        prompt_recreate "${recreate[@]}"
        return $?
    fi

    return 0
}

# -s var=val
# docker-app parses the "val" portion as a YAML value, which will cause it to infer a type
# unquoted numbers cause issues when they are rendered with the inferred type (5.00 becomes 5)
# we add quotes to the arguments in order to encourage docker-app to treat all values as strings
function append_dockerapp_arg() {
    local opt="$1"

    local var
    local val

    IFS== read var val <<< $2

    DOCKERAPP_ARGS="${DOCKERAPP_ARGS} ${opt} '${var}=\"${val}\"'"
    # DOCKERAPP_ARGS="${DOCKERAPP_ARGS} ${opt} ${var}=${val}"
}

function create_network() {
    if [[ -z "$(docker network ls -qf "name=${NETWORK_NAME}")" ]]; then
        docker network create --subnet "${NETWORK_SUBNET}" --gateway "${NETWORK_GATEWAY}" "${NETWORK_NAME}"
    fi
}

function debug() {
    if (( NIMBUS_DEBUG > 0 )); then
        echo "$@"
    fi
}

function output() {
    if (( NIMBUS_OUTPUT > 0 )); then
        echo "$@"
    fi
}

readonly NIMBUS_RELEASE_VERSION="UNRELEASED"
readonly NIMBUS_RELEASE_DATE="UNRELEASED"

BASH_VERBOSE=""

DEFAULT_REPOSITORY="admpresales"

PROJECT=""
VOLUME_MOUNT_IDEA=""
VOLUME_MOUNT_M2=""
IDEA="IdeaProjects_docker"

COMPOSE_COMMAND="${NIMBUS_COMPOSE_COMMAND-docker-compose}"
COMPOSE_ACTION=""
COMPOSE_ARGS="${NIMBUS_COMPOSE_ARGS}"

DOCKERAPP_COMMAND="${NIMBUS_DOCKERAPP_COMMAND-docker-app}"
DOCKERAPP_ACTION=""
DOCKERAPP_ARGS="${NIMBUS_DOCKERAPP_ARGS}"

NIMBUS_BASEDIR="${NIMBUS_BASEDIR-$HOME/.nimbusapp}"
NIMBUS_DOCKERHUB_URL="${NIMBUS_DOCKERHUB_URL-https://hub.docker.com}"
NIMBUS_DOCKERHUB_TIMEOUT="${NIMBUS_DOCKERHUB_TIMEOUT-10}"
NIMBUS_DEBUG="${NIMBUS_DEBUG-0}"
NIMBUS_OUTPUT="${NIMBUS_OUTPUT-1}"
NIMBUS_FORCE="${NIMBUS_FORCE-0}"

NETWORK_NAME="${NETWORK_NAME-demo-net}"
NETWORK_SUBNET="${NETWORK_SUBNET-172.50.0.0/16}"
NETWORK_GATEWAY="${NETWORK_GATEWAY-172.50.0.1}"

PRESERVE_VOLUMES=0

ENV_FILE="${NIMBUS_BASEDIR}/apps.config"

if [[ "$1" != "-"* ]]; then
    IMAGE="$1"

    shift
    if [[ "${IMAGE}" = *"help"* ]]; then
        usage
        exit 0
    fi

    if [[ "${IMAGE}" = *"version"* ]]; then
        version_info
        exit 0
    fi
fi

while [[ "$1" != "" ]]; do
    PARAM="$1"
    VALUE="$2"

    case "$PARAM" in
    -h | --help | help)
        usage
        exit 0
        ;;
    --version)
        version_info
        exit 0
        ;;
    -d|--debug)
        (( NIMBUS_DEBUG++ ))
        if (( NIMBUS_DEBUG >= 2 )); then
            BASH_VERBOSE="-v"
        fi
        shift
        ;;
    -s | --set)
        append_dockerapp_arg "$PARAM" "$VALUE"
        shift 2
        ;;
    # TODO: Intellij checks should happen after image parsing
    -v)
         # check to see if intellij is being called.
        if [[ "${IMAGE}" == *intellij* ]]
        then
            # the \ \ forces spaces which are needed for the sed statment below for proper docker-compose format
            VOLUME_MOUNT_IDEA="\ \ \ \ - type: bind\n\ \ \ \ \ \ source: ${HOME}\/${IDEA}\n\ \ \ \ \ \ target: \/home\/demo/\/IdeaProjects"
            create_intellij_mount_points
        else
            output "The '-v' option is only available with Intellij at this time.  Ignoring."
        fi
        shift
        ;;
    -m)
        # check to see if intellij is being called.
        if [[ "${IMAGE}" == *"intellij"* ]]
        then
            # the \ \ forces spaces which are needed for the sed statment below for proper docker-compose format
            VOLUME_MOUNT_M2="\ \ \ \ - type: bind\n\ \ \ \ \ \ source: ${HOME}\/\.m2\n\ \ \ \ \ \ target: \/home\/demo\/\.m2"
            create_intellij_mount_points
        else
            output "The '-m' option is only available with Intellij at this time.  Ignoring."
        fi
        shift
        ;;
    -p)
        PROJECT="${VALUE}"
        shift
        shift
        ;;
    -f|--force)
        NIMBUS_FORCE=1
        shift
        ;;
    --preserve-volumes)
        PRESERVE_VOLUMES=1
        shift
        ;;
    render|inspect)
        DOCKERAPP_ACTION="${PARAM}"
        shift
        break
        ;;
    down | start | stop | ps | rm | logs | restart )
        COMPOSE_ACTION="${PARAM}"
        shift
        break
        ;;
    pull)
        DOCKERAPP_ACTION="render"
        COMPOSE_ACTION="pull"
        shift
        break
        ;;
    up)
        DOCKERAPP_ACTION="render"
        
        # Start in background if required
        if [[ "$@" == *"--no-start"* ]]; then
            COMPOSE_ACTION="up"
        else 
            COMPOSE_ACTION="up -d"
        fi

        shift
        break
        ;;
    *)
        output "Invalid argument passed: $1"
        usage
        exit 1
    esac
done

if [[ "$IMAGE" == */* ]]; then
    IFS=/ read REPOSITORY IMAGE <<< $IMAGE
fi

if [[ "$IMAGE" == *:* ]]; then
    IFS=: read IMAGE VERSION <<< $IMAGE
fi

#create a project name for the docker-compose based on the image name.
if [[ -z $PROJECT ]]; then

    if [[ -z $IMAGE ]]; then
        echo "ERROR: Please specify an image or project name." >&2
        exit 1;
    fi

    PROJECT="${IMAGE%.dockerapp}"
fi

if [[ -n $PROJECT ]]; then
    apps_load "${PROJECT}"
fi


if [[ -z $VERSION ]]; then
    echo "No version number specified!" >&2
    echo >&2
    echo "If this is your first time using $IMAGE, please specify a version number:" >&2
    echo "    $0 $IMAGE:<version_number> ${COMPOSE_ACTION:-$DOCKERAPP_ACTION}" >&2
    echo >&2
    echo "The version number you choose will be remembered for future commands." >&2
    exit 1
fi

# Apply defaults if necessary
REPOSITORY="${REPOSITORY-$DEFAULT_REPOSITORY}"
IMAGE="${IMAGE%.dockerapp}"

debug "Repository: $REPOSITORY"
debug "Image: $IMAGE"
debug "Version: $VERSION"
debug "Project: $PROJECT"

if [[ -z $IMAGE ]]; then
    echo "ERROR: Could not determine image name. Please specify an image or project name." >&2
    exit 1
fi

if [[ -z "${COMPOSE_ACTION}" && -z "${DOCKERAPP_ACTION}" ]]; then
    output "You must specify a command"
    usage
    exit 1
fi

create_network

COMPOSE_ARGS="$@"
COMPOSE_DIR="${NIMBUS_BASEDIR}/cache/${PROJECT}/${REPOSITORY}/${IMAGE}/${VERSION}"
COMPOSE_FILE="${COMPOSE_DIR}/${IMAGE}.yml"
COMPOSE_BACKUP="${COMPOSE_FILE}.bk"

if [[ -n "${DOCKERAPP_ACTION}" ]]; then
    if ! docker login; then
        rc=$?
        output "Docker login failed ($rc)" >&2
        exit $rc
    fi

    if curl -s --connect-timeout "${NIMBUS_DOCKERHUB_TIMEOUT}" "${NIMBUS_DOCKERHUB_URL}" > /dev/null 2>&1; then
        DOCKERAPP_COMMAND="${DOCKERAPP_COMMAND} ${DOCKERAPP_ACTION} ${DOCKERAPP_ARGS} ${REPOSITORY}/${IMAGE}:${VERSION}"

        if [[ "$DOCKERAPP_ACTION" == "render" ]]; then
            DOCKERAPP_COMMAND="${DOCKERAPP_COMMAND} > ${COMPOSE_FILE}"

            # Backup previous successful attempts in case this try fails
            # Ignore empty files (assume previous failure)
            if [[ -s "${COMPOSE_FILE}" ]]; then
                mv ${BASH_VERBOSE} "${COMPOSE_FILE}" "${COMPOSE_BACKUP}"
            else
                rm ${BASH_VERBOSE} -f "${COMPOSE_FILE}"
            fi
        fi # action == render

        mkdir ${BASH_VERBOSE} -p "${COMPOSE_DIR}"

        debug "Running: ${DOCKERAPP_COMMAND}"

        if ! eval "${DOCKERAPP_COMMAND}"; then
            # Something went wrong, replace the compose backup
            if [[ -f "${COMPOSE_BACKUP}" ]]; then
                mv -f ${BASH_VERBOSE} "${COMPOSE_BACKUP}" "${COMPOSE_FILE}"
            fi

            output "ERROR: Could not render" >&2
            exit 1
        fi # eval

        if [[ -n "${VOLUME_MOUNT_IDEA}" ]]; then
            debug "Mounting IDEA: ${VOLUME_MOUNT_IDEA}"
            sed -i "/volumes:/a ${VOLUME_MOUNT_IDEA}" "${COMPOSE_FILE}"
        fi

        if [[ -n "${VOLUME_MOUNT_M2}" ]]; then
            debug "Mounting M2: ${VOLUME_MOUNT_M2}"
            sed -i "/volumes:/a ${VOLUME_MOUNT_M2}" "${COMPOSE_FILE}"
        fi


        if [[ "$DOCKERAPP_ACTION" == "render" && -z "${COMPOSE_ACTION}" ]]; then
            cat "${COMPOSE_FILE}"
        fi
    else # curl check
        if [[ ! -f "${COMPOSE_FILE}" ]]; then
            output "ERROR: No connection to Docker Hub: ${NIMBUS_DOCKERHUB_URL} (${NIMBUS_DOCKERHUB_TIMEOUT}s)" >&2
            exit 1
        else
            output "No connection to Docker Hub, using cached file!"
            debug "Docker Hub: ${NIMBUS_DOCKERHUB_URL} Timeout: ${NIMBUS_DOCKERHUB_TIMEOUT}"
            debug "Cached File: ${COMPOSE_FILE}"
        fi
    fi # curl check
fi

if [[ ! -f "$COMPOSE_FILE" ]]; then
    echo -e "${C_RED}ERROR${C_REG}: Could not find ${IMAGE}:${VERSION} (${PROJECT}) - do you need to create it with \`nimbusapp up'" >&2
    exit 1
fi

if [[ "$COMPOSE_ACTION" == "down" && "$NIMBUS_FORCE" -eq 0 ]]; then
    if ! prompt_delete; then
        exit 1
    fi
fi

if [[ "$COMPOSE_ACTION" == "up -d" && "$NIMBUS_FORCE" -eq 0 ]]; then
    if ! check_recreate; then
        exit 1
    fi
fi

if [[ -n "${COMPOSE_ACTION}" ]]; then
    if [[ $COMPOSE_ACTION == *"up"* && $PRESERVE_VOLUMES -eq 0 ]]; then
        COMPOSE_ARGS="$COMPOSE_ARGS -V"
    fi

    if [[ $COMPOSE_ACTION == *"down"* && $PRESERVE_VOLUMES -eq 0 ]]; then
        COMPOSE_ARGS="$COMPOSE_ARGS -v"
    fi

    COMPOSE_COMMAND="${COMPOSE_COMMAND} -p ${PROJECT} -f ${COMPOSE_FILE} ${COMPOSE_ACTION} ${COMPOSE_ARGS}"

    debug "Running: ${COMPOSE_COMMAND}"

    if ! eval "${COMPOSE_COMMAND}"; then
        rc=$?
        echo "Failed to run compose: $rc" >&2
        exit $rc
    fi
fi

apps_save
